# Архитектура

## Общая структура

Система строится по принципу разделения ответственности на слои:

- UI слой — отвечает только за взаимодействие с пользователем (TUI)
- Game Core — содержит игровую логику и состояние игры
- Application слой — управляет процессом игры и связывает UI с логикой
- Data слой — отвечает за хранение результатов

Это позволяет менять интерфейс или способ хранения данных без изменения игровой логики.

## Схема создания объектов

Создание основных объектов происходит при запуске приложения.

Последовательность инициализации:

1. Создаётся *GameStateMachine*
2. Создаётся *Leaderboard*
3. Создаётся GameController, которому передаются ссылки на *GameStateMachine* и *Leaderboard*
4. При старте новой партии GameController создаёт
*GameSession* и *GameBoard*

*GameController* выступает центральной точкой управления жизненным циклом игры.

## Обработка событий
Система работает по событийной схеме.
Источником событий является пользователь, работающий через клавиатуру (TUI).

Поток обработки:
1. Пользователь вводит команду, например: ход, старт игры, выход.
2. UI преобразует ввод в действие, например, Move.
3. UI передаёт действие в *GameController*.
4. *GameController* проверяет состояние через *GameStateMachine* и вызывает соответствующие методы *GameBoard* и *GameSession*
5. После изменения состояния UI обновляет отображение.

UI не содержит игровой логики — только передаёт команды.

## Связь с технологиями
### .NET / C#

Используются как основная платформа. Все классы реализуются как обычные C# классы.

### Terminal.Gui

Используется только в UI-слое для обработки клавиатуры отрисовка поля, меню и таблицы.
Игровая логика никак не зависит от Terminal.Gui.

### PostgreSQL + Dapper

PostgreSQL и Dapper используются в слое данных, где Leaderboard работает через репозиторий результатов, а Dapper берёт на себя выполнение запросов к базе. При этом игровая логика не знает о существовании БД напрямую.

## Принципы поведения системы

Игровая логика полностью изолирована от интерфейса. Все изменения состояния проходят через GameController, который выступает единой точкой управления. GameStateMachine контролирует, какие действия допустимы в текущий момент. Данные о результатах сохраняются только после того, как партия завершена. UI не изменяет состояние игры напрямую, а только передаёт команды контроллеру.

## Тестирование типовых сценариев

Тестируются основные пользовательские сценарии. При запуске игры проверяется, что создаётся сессия и поле. Корректный ход должен приводить к тому, что элементы меняются местами, совпадения удаляются и начисляются очки. Некорректный ход, напротив, не должен менять состояние поля. При завершении партии проверяется фиксация результата и его сохранение в таблице лидеров. Также тестируются переходы состояний — например, что нельзя сделать ход вне режима игры